{
  "version": 3,
  "sources": ["../../node_modules/@tanstack/react-virtual/build/lib/_virtual/_rollupPluginBabelHelpers.mjs", "../../node_modules/@tanstack/virtual-core/build/lib/_virtual/_rollupPluginBabelHelpers.mjs", "../../node_modules/@tanstack/virtual-core/src/utils.ts", "../../node_modules/@tanstack/virtual-core/src/index.ts", "../../node_modules/@tanstack/react-virtual/src/index.tsx"],
  "sourcesContent": ["/**\n * react-virtual\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n//# sourceMappingURL=_rollupPluginBabelHelpers.mjs.map\n", "/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n//# sourceMappingURL=_rollupPluginBabelHelpers.mjs.map\n", "export type NoInfer<A extends any> = [A][A extends any ? 0 : never]\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\nexport function memo<TDeps extends readonly any[], TResult>(\n  getDeps: () => [...TDeps],\n  fn: (...args: NoInfer<[...TDeps]>) => TResult,\n  opts: {\n    key: false | string\n    debug?: () => any\n    onChange?: (result: TResult) => void\n    initialDeps?: TDeps\n  },\n) {\n  let deps = opts.initialDeps ?? []\n  let result: TResult | undefined\n\n  return (): TResult => {\n    let depTime: number\n    if (opts.key && opts.debug?.()) depTime = Date.now()\n\n    const newDeps = getDeps()\n\n    const depsChanged =\n      newDeps.length !== deps.length ||\n      newDeps.some((dep: any, index: number) => deps[index] !== dep)\n\n    if (!depsChanged) {\n      return result!\n    }\n\n    deps = newDeps\n\n    let resultTime: number\n    if (opts.key && opts.debug?.()) resultTime = Date.now()\n\n    result = fn(...newDeps)\n\n    if (opts.key && opts.debug?.()) {\n      const depEndTime = Math.round((Date.now() - depTime!) * 100) / 100\n      const resultEndTime = Math.round((Date.now() - resultTime!) * 100) / 100\n      const resultFpsPercentage = resultEndTime / 16\n\n      const pad = (str: number | string, num: number) => {\n        str = String(str)\n        while (str.length < num) {\n          str = ' ' + str\n        }\n        return str\n      }\n\n      console.info(\n        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n              0,\n              Math.min(120 - 120 * resultFpsPercentage, 120),\n            )}deg 100% 31%);`,\n        opts?.key,\n      )\n    }\n\n    opts?.onChange?.(result)\n\n    return result!\n  }\n}\n\nexport function notUndefined<T>(value: T | undefined, msg?: string): T {\n  if (value === undefined) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : ''}`)\n  } else {\n    return value\n  }\n}\n\nexport const approxEqual = (a: number, b: number) => Math.abs(a - b) < 1\n", "import { approxEqual, memo, notUndefined } from './utils'\n\nexport * from './utils'\n\n//\n\ntype ScrollDirection = 'forward' | 'backward'\n\ntype ScrollAlignment = 'start' | 'center' | 'end' | 'auto'\n\ntype ScrollBehavior = 'auto' | 'smooth'\n\nexport interface ScrollToOptions {\n  align?: ScrollAlignment\n  behavior?: ScrollBehavior\n}\n\ntype ScrollToOffsetOptions = ScrollToOptions\n\ntype ScrollToIndexOptions = ScrollToOptions\n\nexport interface Range {\n  startIndex: number\n  endIndex: number\n  overscan: number\n  count: number\n}\n\ntype Key = number | string\n\nexport interface VirtualItem {\n  key: Key\n  index: number\n  start: number\n  end: number\n  size: number\n  lane: number\n}\n\ninterface Rect {\n  width: number\n  height: number\n}\n\n//\n\nexport const defaultKeyExtractor = (index: number) => index\n\nexport const defaultRangeExtractor = (range: Range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0)\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1)\n\n  const arr = []\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i)\n  }\n\n  return arr\n}\n\nexport const observeElementRect = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = (rect: Rect) => {\n    const { width, height } = rect\n    cb({ width: Math.round(width), height: Math.round(height) })\n  }\n\n  handler(element.getBoundingClientRect())\n\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0]\n    if (entry?.borderBoxSize) {\n      const box = entry.borderBoxSize[0]\n      if (box) {\n        handler({ width: box.inlineSize, height: box.blockSize })\n        return\n      }\n    }\n    handler(element.getBoundingClientRect())\n  })\n\n  observer.observe(element, { box: 'border-box' })\n\n  return () => {\n    observer.unobserve(element)\n  }\n}\n\nexport const observeWindowRect = (\n  instance: Virtualizer<Window, any>,\n  cb: (rect: Rect) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight })\n  }\n  handler()\n\n  element.addEventListener('resize', handler, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener('resize', handler)\n  }\n}\n\nexport const observeElementOffset = <T extends Element>(\n  instance: Virtualizer<T, any>,\n  cb: (offset: number) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb(element[instance.options.horizontal ? 'scrollLeft' : 'scrollTop'])\n  }\n  handler()\n\n  element.addEventListener('scroll', handler, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n  }\n}\n\nexport const observeWindowOffset = (\n  instance: Virtualizer<Window, any>,\n  cb: (offset: number) => void,\n) => {\n  const element = instance.scrollElement\n  if (!element) {\n    return\n  }\n\n  const handler = () => {\n    cb(element[instance.options.horizontal ? 'scrollX' : 'scrollY'])\n  }\n  handler()\n\n  element.addEventListener('scroll', handler, {\n    passive: true,\n  })\n\n  return () => {\n    element.removeEventListener('scroll', handler)\n  }\n}\n\nexport const measureElement = <TItemElement extends Element>(\n  element: TItemElement,\n  entry: ResizeObserverEntry | undefined,\n  instance: Virtualizer<any, TItemElement>,\n) => {\n  if (entry?.borderBoxSize) {\n    const box = entry.borderBoxSize[0]\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? 'inlineSize' : 'blockSize'],\n      )\n      return size\n    }\n  }\n  return Math.round(\n    element.getBoundingClientRect()[\n      instance.options.horizontal ? 'width' : 'height'\n    ],\n  )\n}\n\nexport const windowScroll = <T extends Window>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport const elementScroll = <T extends Element>(\n  offset: number,\n  {\n    adjustments = 0,\n    behavior,\n  }: { adjustments?: number; behavior?: ScrollBehavior },\n  instance: Virtualizer<T, any>,\n) => {\n  const toOffset = offset + adjustments\n\n  instance.scrollElement?.scrollTo?.({\n    [instance.options.horizontal ? 'left' : 'top']: toOffset,\n    behavior,\n  })\n}\n\nexport interface VirtualizerOptions<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  // Required from the user\n  count: number\n  getScrollElement: () => TScrollElement | null\n  estimateSize: (index: number) => number\n\n  // Required from the framework adapter (but can be overridden)\n  scrollToFn: (\n    offset: number,\n    options: { adjustments?: number; behavior?: ScrollBehavior },\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => void\n  observeElementRect: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (rect: Rect) => void,\n  ) => void | (() => void)\n  observeElementOffset: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    cb: (offset: number) => void,\n  ) => void | (() => void)\n\n  // Optional\n  debug?: any\n  initialRect?: Rect\n  onChange?: (\n    instance: Virtualizer<TScrollElement, TItemElement>,\n    sync: boolean,\n  ) => void\n  measureElement?: (\n    element: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n    instance: Virtualizer<TScrollElement, TItemElement>,\n  ) => number\n  overscan?: number\n  horizontal?: boolean\n  paddingStart?: number\n  paddingEnd?: number\n  scrollPaddingStart?: number\n  scrollPaddingEnd?: number\n  initialOffset?: number\n  getItemKey?: (index: number) => Key\n  rangeExtractor?: (range: Range) => number[]\n  scrollMargin?: number\n  scrollingDelay?: number\n  indexAttribute?: string\n  initialMeasurementsCache?: VirtualItem[]\n  lanes?: number\n}\n\nexport class Virtualizer<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n> {\n  private unsubs: (void | (() => void))[] = []\n  options!: Required<VirtualizerOptions<TScrollElement, TItemElement>>\n  scrollElement: TScrollElement | null = null\n  isScrolling: boolean = false\n  private isScrollingTimeoutId: ReturnType<typeof setTimeout> | null = null\n  private scrollToIndexTimeoutId: ReturnType<typeof setTimeout> | null = null\n  measurementsCache: VirtualItem[] = []\n  private itemSizeCache = new Map<Key, number>()\n  private pendingMeasuredCacheIndexes: number[] = []\n  scrollRect: Rect\n  scrollOffset: number\n  scrollDirection: ScrollDirection | null = null\n  private scrollAdjustments: number = 0\n  measureElementCache = new Map<Key, TItemElement>()\n  private observer = (() => {\n    let _ro: ResizeObserver | null = null\n\n    const get = () => {\n      if (_ro) {\n        return _ro\n      } else if (typeof ResizeObserver !== 'undefined') {\n        return (_ro = new ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            this._measureElement(entry.target as TItemElement, entry)\n          })\n        }))\n      } else {\n        return null\n      }\n    }\n\n    return {\n      disconnect: () => get()?.disconnect(),\n      observe: (target: Element) =>\n        get()?.observe(target, { box: 'border-box' }),\n      unobserve: (target: Element) => get()?.unobserve(target),\n    }\n  })()\n  range: { startIndex: number; endIndex: number } | null = null\n\n  constructor(opts: VirtualizerOptions<TScrollElement, TItemElement>) {\n    this.setOptions(opts)\n    this.scrollRect = this.options.initialRect\n    this.scrollOffset = this.options.initialOffset\n    this.measurementsCache = this.options.initialMeasurementsCache\n    this.measurementsCache.forEach((item) => {\n      this.itemSizeCache.set(item.key, item.size)\n    })\n\n    this.maybeNotify()\n  }\n\n  setOptions = (opts: VirtualizerOptions<TScrollElement, TItemElement>) => {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      initialOffset: 0,\n      overscan: 1,\n      paddingStart: 0,\n      paddingEnd: 0,\n      scrollPaddingStart: 0,\n      scrollPaddingEnd: 0,\n      horizontal: false,\n      getItemKey: defaultKeyExtractor,\n      rangeExtractor: defaultRangeExtractor,\n      onChange: () => {},\n      measureElement,\n      initialRect: { width: 0, height: 0 },\n      scrollMargin: 0,\n      scrollingDelay: 150,\n      indexAttribute: 'data-index',\n      initialMeasurementsCache: [],\n      lanes: 1,\n      ...opts,\n    }\n  }\n\n  private notify = (sync: boolean) => {\n    this.options.onChange?.(this, sync)\n  }\n\n  private maybeNotify = memo(\n    () => {\n      this.calculateRange()\n\n      return [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ]\n    },\n    (isScrolling) => {\n      this.notify(isScrolling)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'maybeNotify',\n      debug: () => this.options.debug,\n      initialDeps: [\n        this.isScrolling,\n        this.range ? this.range.startIndex : null,\n        this.range ? this.range.endIndex : null,\n      ] as [boolean, number | null, number | null],\n    },\n  )\n\n  private cleanup = () => {\n    this.unsubs.filter(Boolean).forEach((d) => d!())\n    this.unsubs = []\n    this.scrollElement = null\n  }\n\n  _didMount = () => {\n    this.measureElementCache.forEach(this.observer.observe)\n    return () => {\n      this.observer.disconnect()\n      this.cleanup()\n    }\n  }\n\n  _willUpdate = () => {\n    const scrollElement = this.options.getScrollElement()\n\n    if (this.scrollElement !== scrollElement) {\n      this.cleanup()\n\n      this.scrollElement = scrollElement\n\n      this._scrollToOffset(this.scrollOffset, {\n        adjustments: undefined,\n        behavior: undefined,\n      })\n\n      this.unsubs.push(\n        this.options.observeElementRect(this, (rect) => {\n          this.scrollRect = rect\n          this.maybeNotify()\n        }),\n      )\n\n      this.unsubs.push(\n        this.options.observeElementOffset(this, (offset) => {\n          this.scrollAdjustments = 0\n\n          if (this.scrollOffset === offset) {\n            return\n          }\n\n          if (this.isScrollingTimeoutId !== null) {\n            clearTimeout(this.isScrollingTimeoutId)\n            this.isScrollingTimeoutId = null\n          }\n\n          this.isScrolling = true\n          this.scrollDirection =\n            this.scrollOffset < offset ? 'forward' : 'backward'\n          this.scrollOffset = offset\n\n          this.maybeNotify()\n\n          this.isScrollingTimeoutId = setTimeout(() => {\n            this.isScrollingTimeoutId = null\n            this.isScrolling = false\n            this.scrollDirection = null\n\n            this.maybeNotify()\n          }, this.options.scrollingDelay)\n        }),\n      )\n    }\n  }\n\n  private getSize = () => {\n    return this.scrollRect[this.options.horizontal ? 'width' : 'height']\n  }\n\n  private memoOptions = memo(\n    () => [\n      this.options.count,\n      this.options.paddingStart,\n      this.options.scrollMargin,\n      this.options.getItemKey,\n    ],\n    (count, paddingStart, scrollMargin, getItemKey) => {\n      this.pendingMeasuredCacheIndexes = []\n      return {\n        count,\n        paddingStart,\n        scrollMargin,\n        getItemKey,\n      }\n    },\n    {\n      key: false,\n    },\n  )\n\n  private getFurthestMeasurement = (\n    measurements: VirtualItem[],\n    index: number,\n  ) => {\n    const furthestMeasurementsFound = new Map<number, true>()\n    const furthestMeasurements = new Map<number, VirtualItem>()\n    for (let m = index - 1; m >= 0; m--) {\n      const measurement = measurements[m]!\n\n      if (furthestMeasurementsFound.has(measurement.lane)) {\n        continue\n      }\n\n      const previousFurthestMeasurement = furthestMeasurements.get(\n        measurement.lane,\n      )\n      if (\n        previousFurthestMeasurement == null ||\n        measurement.end > previousFurthestMeasurement.end\n      ) {\n        furthestMeasurements.set(measurement.lane, measurement)\n      } else if (measurement.end < previousFurthestMeasurement.end) {\n        furthestMeasurementsFound.set(measurement.lane, true)\n      }\n\n      if (furthestMeasurementsFound.size === this.options.lanes) {\n        break\n      }\n    }\n\n    return furthestMeasurements.size === this.options.lanes\n      ? Array.from(furthestMeasurements.values()).sort(\n          (a, b) => a.end - b.end,\n        )[0]\n      : undefined\n  }\n\n  private getMeasurements = memo(\n    () => [this.memoOptions(), this.itemSizeCache],\n    ({ count, paddingStart, scrollMargin, getItemKey }, itemSizeCache) => {\n      const min =\n        this.pendingMeasuredCacheIndexes.length > 0\n          ? Math.min(...this.pendingMeasuredCacheIndexes)\n          : 0\n      this.pendingMeasuredCacheIndexes = []\n\n      const measurements = this.measurementsCache.slice(0, min)\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i)\n\n        const furthestMeasurement =\n          this.options.lanes === 1\n            ? measurements[i - 1]\n            : this.getFurthestMeasurement(measurements, i)\n\n        const start = furthestMeasurement\n          ? furthestMeasurement.end\n          : paddingStart + scrollMargin\n\n        const measuredSize = itemSizeCache.get(key)\n        const size =\n          typeof measuredSize === 'number'\n            ? measuredSize\n            : this.options.estimateSize(i)\n\n        const end = start + size\n\n        const lane = furthestMeasurement\n          ? furthestMeasurement.lane\n          : i % this.options.lanes\n\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key,\n          lane,\n        }\n      }\n\n      this.measurementsCache = measurements\n\n      return measurements\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug,\n    },\n  )\n\n  calculateRange = memo(\n    () => [this.getMeasurements(), this.getSize(), this.scrollOffset],\n    (measurements, outerSize, scrollOffset) => {\n      return (this.range =\n        measurements.length > 0 && outerSize > 0\n          ? calculateRange({\n              measurements,\n              outerSize,\n              scrollOffset,\n            })\n          : null)\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug,\n    },\n  )\n\n  private getIndexes = memo(\n    () => [\n      this.options.rangeExtractor,\n      this.calculateRange(),\n      this.options.overscan,\n      this.options.count,\n    ],\n    (rangeExtractor, range, overscan, count) => {\n      return range === null\n        ? []\n        : rangeExtractor({\n            ...range,\n            overscan,\n            count,\n          })\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  indexFromElement = (node: TItemElement) => {\n    const attributeName = this.options.indexAttribute\n    const indexStr = node.getAttribute(attributeName)\n\n    if (!indexStr) {\n      console.warn(\n        `Missing attribute name '${attributeName}={index}' on measured element.`,\n      )\n      return -1\n    }\n\n    return parseInt(indexStr, 10)\n  }\n\n  private _measureElement = (\n    node: TItemElement,\n    entry: ResizeObserverEntry | undefined,\n  ) => {\n    const item = this.measurementsCache[this.indexFromElement(node)]\n\n    if (!item || !node.isConnected) {\n      this.measureElementCache.forEach((cached, key) => {\n        if (cached === node) {\n          this.observer.unobserve(node)\n          this.measureElementCache.delete(key)\n        }\n      })\n      return\n    }\n\n    const prevNode = this.measureElementCache.get(item.key)\n\n    if (prevNode !== node) {\n      if (prevNode) {\n        this.observer.unobserve(prevNode)\n      }\n      this.observer.observe(node)\n      this.measureElementCache.set(item.key, node)\n    }\n\n    const measuredItemSize = this.options.measureElement(node, entry, this)\n\n    this.resizeItem(item, measuredItemSize)\n  }\n\n  resizeItem = (item: VirtualItem, size: number) => {\n    const itemSize = this.itemSizeCache.get(item.key) ?? item.size\n    const delta = size - itemSize\n\n    if (delta !== 0) {\n      if (item.start < this.scrollOffset) {\n        if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n          console.info('correction', delta)\n        }\n\n        this._scrollToOffset(this.scrollOffset, {\n          adjustments: (this.scrollAdjustments += delta),\n          behavior: undefined,\n        })\n      }\n\n      this.pendingMeasuredCacheIndexes.push(item.index)\n      this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size))\n\n      this.notify(false)\n    }\n  }\n\n  measureElement = (node: TItemElement | null) => {\n    if (!node) {\n      return\n    }\n\n    this._measureElement(node, undefined)\n  }\n\n  getVirtualItems = memo(\n    () => [this.getIndexes(), this.getMeasurements()],\n    (indexes, measurements) => {\n      const virtualItems: VirtualItem[] = []\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        const i = indexes[k]!\n        const measurement = measurements[i]!\n\n        virtualItems.push(measurement)\n      }\n\n      return virtualItems\n    },\n    {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug,\n    },\n  )\n\n  getVirtualItemForOffset = (offset: number) => {\n    const measurements = this.getMeasurements()\n\n    return notUndefined(\n      measurements[\n        findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index: number) => notUndefined(measurements[index]).start,\n          offset,\n        )\n      ],\n    )\n  }\n\n  getOffsetForAlignment = (toOffset: number, align: ScrollAlignment) => {\n    const size = this.getSize()\n\n    if (align === 'auto') {\n      if (toOffset <= this.scrollOffset) {\n        align = 'start'\n      } else if (toOffset >= this.scrollOffset + size) {\n        align = 'end'\n      } else {\n        align = 'start'\n      }\n    }\n\n    if (align === 'start') {\n      toOffset = toOffset\n    } else if (align === 'end') {\n      toOffset = toOffset - size\n    } else if (align === 'center') {\n      toOffset = toOffset - size / 2\n    }\n\n    const scrollSizeProp = this.options.horizontal\n      ? 'scrollWidth'\n      : 'scrollHeight'\n    const scrollSize = this.scrollElement\n      ? 'document' in this.scrollElement\n        ? this.scrollElement.document.documentElement[scrollSizeProp]\n        : this.scrollElement[scrollSizeProp]\n      : 0\n\n    const maxOffset = scrollSize - this.getSize()\n\n    return Math.max(Math.min(maxOffset, toOffset), 0)\n  }\n\n  getOffsetForIndex = (index: number, align: ScrollAlignment = 'auto') => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    const measurement = notUndefined(this.getMeasurements()[index])\n\n    if (align === 'auto') {\n      if (\n        measurement.end >=\n        this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd\n      ) {\n        align = 'end'\n      } else if (\n        measurement.start <=\n        this.scrollOffset + this.options.scrollPaddingStart\n      ) {\n        align = 'start'\n      } else {\n        return [this.scrollOffset, align] as const\n      }\n    }\n\n    const toOffset =\n      align === 'end'\n        ? measurement.end + this.options.scrollPaddingEnd\n        : measurement.start - this.options.scrollPaddingStart\n\n    return [this.getOffsetForAlignment(toOffset, align), align] as const\n  }\n\n  private isDynamicMode = () => this.measureElementCache.size > 0\n\n  private cancelScrollToIndex = () => {\n    if (this.scrollToIndexTimeoutId !== null) {\n      clearTimeout(this.scrollToIndexTimeoutId)\n      this.scrollToIndexTimeoutId = null\n    }\n  }\n\n  scrollToOffset = (\n    toOffset: number,\n    { align = 'start', behavior }: ScrollToOffsetOptions = {},\n  ) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  scrollToIndex = (\n    index: number,\n    { align: initialAlign = 'auto', behavior }: ScrollToIndexOptions = {},\n  ) => {\n    index = Math.max(0, Math.min(index, this.options.count - 1))\n\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    const [toOffset, align] = this.getOffsetForIndex(index, initialAlign)\n\n    this._scrollToOffset(toOffset, { adjustments: undefined, behavior })\n\n    if (behavior !== 'smooth' && this.isDynamicMode()) {\n      this.scrollToIndexTimeoutId = setTimeout(() => {\n        this.scrollToIndexTimeoutId = null\n\n        const elementInDOM = this.measureElementCache.has(\n          this.options.getItemKey(index),\n        )\n\n        if (elementInDOM) {\n          const [toOffset] = this.getOffsetForIndex(index, align)\n\n          if (!approxEqual(toOffset, this.scrollOffset)) {\n            this.scrollToIndex(index, { align, behavior })\n          }\n        } else {\n          this.scrollToIndex(index, { align, behavior })\n        }\n      })\n    }\n  }\n\n  scrollBy = (delta: number, { behavior }: ScrollToOffsetOptions = {}) => {\n    this.cancelScrollToIndex()\n\n    if (behavior === 'smooth' && this.isDynamicMode()) {\n      console.warn(\n        'The `smooth` scroll behavior is not fully supported with dynamic size.',\n      )\n    }\n\n    this._scrollToOffset(this.scrollOffset + delta, {\n      adjustments: undefined,\n      behavior,\n    })\n  }\n\n  getTotalSize = () =>\n    (this.getMeasurements()[this.options.count - 1]?.end ||\n      this.options.paddingStart) -\n    this.options.scrollMargin +\n    this.options.paddingEnd\n\n  private _scrollToOffset = (\n    offset: number,\n    {\n      adjustments,\n      behavior,\n    }: {\n      adjustments: number | undefined\n      behavior: ScrollBehavior | undefined\n    },\n  ) => {\n    this.options.scrollToFn(offset, { behavior, adjustments }, this)\n  }\n\n  measure = () => {\n    this.itemSizeCache = new Map()\n    this.notify(false)\n  }\n}\n\nconst findNearestBinarySearch = (\n  low: number,\n  high: number,\n  getCurrentValue: (i: number) => number,\n  value: number,\n) => {\n  while (low <= high) {\n    const middle = ((low + high) / 2) | 0\n    const currentValue = getCurrentValue(middle)\n\n    if (currentValue < value) {\n      low = middle + 1\n    } else if (currentValue > value) {\n      high = middle - 1\n    } else {\n      return middle\n    }\n  }\n\n  if (low > 0) {\n    return low - 1\n  } else {\n    return 0\n  }\n}\n\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n}: {\n  measurements: VirtualItem[]\n  outerSize: number\n  scrollOffset: number\n}) {\n  const count = measurements.length - 1\n  const getOffset = (index: number) => measurements[index]!.start\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset)\n  let endIndex = startIndex\n\n  while (\n    endIndex < count &&\n    measurements[endIndex]!.end < scrollOffset + outerSize\n  ) {\n    endIndex++\n  }\n\n  return { startIndex, endIndex }\n}\n", "import * as React from 'react'\nimport { flushSync } from 'react-dom'\nimport {\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  PartialKeys,\n  Virtualizer,\n  VirtualizerOptions,\n  windowScroll,\n} from '@tanstack/virtual-core'\nexport * from '@tanstack/virtual-core'\n\n//\n\nconst useIsomorphicLayoutEffect =\n  typeof document !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<\n  TScrollElement extends Element | Window,\n  TItemElement extends Element,\n>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance, sync) => {\n      if (sync) {\n        flushSync(rerender)\n      } else {\n        rerender()\n      }\n      options.onChange?.(instance, sync)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<\n  TScrollElement extends Element,\n  TItemElement extends Element,\n>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement extends Element>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof document !== 'undefined' ? window : null),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: typeof document !== 'undefined' ? window.scrollY : undefined,\n    ...options,\n  })\n}\n"],
  "mappings": "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",
  "names": ["_extends", "memo", "getDeps", "fn", "opts", "_opts$initialDeps", "deps", "initialDeps", "result", "depTime", "key", "debug", "Date", "now", "newDeps", "depsChanged", "length", "some", "dep", "index", "resultTime", "apply", "depEndTime", "Math", "round", "resultEndTime", "resultFpsPercentage", "pad", "str", "num", "String", "console", "info", "max", "min", "onChange", "notUndefined", "value", "msg", "undefined", "Error", "approxEqual", "a", "b", "abs", "defaultKeyExtractor", "index", "defaultRangeExtractor", "range", "start", "Math", "max", "startIndex", "overscan", "end", "min", "endIndex", "count", "arr", "i", "push", "observeElementRect", "instance", "cb", "element", "scrollElement", "handler", "rect", "width", "height", "round", "getBoundingClientRect", "observer", "ResizeObserver", "entries", "entry", "borderBoxSize", "box", "inlineSize", "blockSize", "observe", "unobserve", "observeWindowRect", "innerWidth", "innerHeight", "addEventListener", "passive", "removeEventListener", "observeElementOffset", "options", "horizontal", "observeWindowOffset", "measureElement", "size", "windowScroll", "offset", "_ref", "_instance$scrollEleme", "_instance$scrollEleme2", "_ref$adjustments", "adjustments", "behavior", "toOffset", "scrollTo", "elementScroll", "_ref2", "_instance$scrollEleme3", "_instance$scrollEleme4", "_ref2$adjustments", "Virtualizer", "opts", "_this", "unsubs", "isScrolling", "isScrollingTimeoutId", "scrollToIndexTimeoutId", "measurementsCache", "itemSizeCache", "Map", "pendingMeasuredCacheIndexes", "scrollDirection", "scrollAdjustments", "measureElementCache", "_ro", "get", "forEach", "_measureElement", "target", "disconnect", "_get", "_get2", "_get3", "setOptions", "Object", "_ref3", "key", "value", "_extends", "debug", "initialOffset", "paddingStart", "paddingEnd", "scrollPaddingStart", "scrollPaddingEnd", "getItemKey", "rangeExtractor", "onChange", "initialRect", "scrollMargin", "scrollingDelay", "indexAttribute", "initialMeasurementsCache", "lanes", "notify", "sync", "maybeNotify", "memo", "calculateRange", "initialDeps", "cleanup", "filter", "Boolean", "d", "_didMount", "_willUpdate", "getScrollElement", "_scrollToOffset", "scrollOffset", "undefined", "scrollRect", "clearTimeout", "setTimeout", "getSize", "memoOptions", "getFurthestMeasurement", "measurements", "furthestMeasurementsFound", "furthestMeasurements", "m", "measurement", "has", "lane", "previousFurthestMeasurement", "set", "Array", "from", "values", "sort", "a", "b", "getMeasurements", "_ref4", "length", "apply", "slice", "furthestMeasurement", "measuredSize", "estimateSize", "outerSize", "getIndexes", "indexFromElement", "node", "attributeName", "indexStr", "getAttribute", "console", "warn", "parseInt", "item", "isConnected", "cached", "prevNode", "measuredItemSize", "resizeItem", "_this$itemSizeCache$g", "itemSize", "delta", "info", "getVirtualItems", "indexes", "virtualItems", "k", "len", "getVirtualItemForOffset", "notUndefined", "findNearestBinarySearch", "getOffsetForAlignment", "align", "scrollSizeProp", "scrollSize", "document", "documentElement", "maxOffset", "getOffsetForIndex", "isDynamicMode", "cancelScrollToIndex", "scrollToOffset", "_temp", "_ref5", "_ref5$align", "scrollToIndex", "_temp2", "_ref6", "_ref6$align", "initialAlign", "_this$getOffsetForInd", "elementInDOM", "_this$getOffsetForInd2", "approxEqual", "scrollBy", "_temp3", "_ref7", "getTotalSize", "_this$getMeasurements", "_ref8", "scrollToFn", "measure", "low", "high", "getCurrentValue", "middle", "currentValue", "_ref9", "getOffset", "useIsomorphicLayoutEffect", "document", "useLayoutEffect", "useEffect", "useVirtualizerBase", "options", "rerender", "useReducer", "resolvedOptions", "_extends", "onChange", "instance", "sync", "flushSync", "_React$useState", "useState", "Virtualizer", "setOptions", "React", "_didMount", "_willUpdate", "useVirtualizer", "observeElementRect", "observeElementOffset", "scrollToFn", "elementScroll", "useWindowVirtualizer", "getScrollElement", "window", "observeWindowRect", "observeWindowOffset", "windowScroll", "initialOffset", "scrollY", "undefined"]
}
