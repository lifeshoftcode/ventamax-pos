import{p as $,m,$ as w,q as j,_ as A,w as x,v as M,x as F,y as O,g as R,b as _,j as E,E as S,R as T,O as q,a as C,c as N,z as P,d as k,e as z,f as L,h as Y,N as B,i as G,k as H,l as J,n as K,A as Q,o as U}from"./@ucast-BZ_ondnv.js";function f(i){return Array.isArray(i)?i:[i]}const V=Object.hasOwn||Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty),d="__caslSubjectType__",l=i=>{const t=typeof i;return t==="string"||t==="function"},W=i=>i.modelName||i.name;function X(i){return V(i,d)?i[d]:W(i.constructor)}function p(i,t,e){for(let s=e;s<t.length;s++)i.push(t[s])}function y(i,t){if(!i||!i.length)return t||[];if(!t||!t.length)return i||[];let e=0,s=0;const r=[];for(;e<i.length&&s<t.length;)i[e].priority<t[s].priority?(r.push(i[e]),e++):(r.push(t[s]),s++);return p(r,i,e),p(r,t,s),r}function h(i,t,e){let s=i.get(t);return s||(s=e(),i.set(t,s)),s}const Z=i=>i;function D(i,t){if(Array.isArray(i.fields)&&!i.fields.length)throw new Error("`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa");if(i.fields&&!t.fieldMatcher)throw new Error('You need to pass "fieldMatcher" option in order to restrict access by fields');if(i.conditions&&!t.conditionsMatcher)throw new Error('You need to pass "conditionsMatcher" option in order to restrict access by conditions')}class I{constructor(t,e,s=0){D(t,e),this.action=e.resolveAction(t.action),this.subject=t.subject,this.inverted=!!t.inverted,this.conditions=t.conditions,this.reason=t.reason,this.origin=t,this.fields=t.fields?f(t.fields):void 0,this.priority=s,this.t=e}i(){return this.conditions&&!this.o&&(this.o=this.t.conditionsMatcher(this.conditions)),this.o}get ast(){const t=this.i();return t?t.ast:void 0}matchesConditions(t){return this.conditions?!t||l(t)?!this.inverted:this.i()(t):!0}matchesField(t){return this.fields?t?(this.fields&&!this.u&&(this.u=this.t.fieldMatcher(this.fields)),this.u(t)):!this.inverted:!0}}function tt(i,t){const e={value:i,prev:t,next:null};return t&&(t.next=e),e}function et(i){i.next&&(i.next.prev=i.prev),i.prev&&(i.prev.next=i.next),i.next=i.prev=null}const st=i=>({value:i.value,prev:i.prev,next:i.next}),g=()=>({rules:[],merged:!1}),v=()=>new Map;class it{constructor(t=[],e={}){this.h=!1,this.l={conditionsMatcher:e.conditionsMatcher,fieldMatcher:e.fieldMatcher,resolveAction:e.resolveAction||Z},this.p=e.anyAction||"manage",this.g=e.anySubjectType||"all",this.$=e.detectSubjectType||X,this.A=t,this.j=this.M(t)}get rules(){return this.A}detectSubjectType(t){return l(t)?t:t?this.$(t):this.g}update(t){const e={rules:t,ability:this,target:this};return this.m("update",e),this.A=t,this.j=this.M(t),this.m("updated",e),this}M(t){const e=new Map;for(let s=t.length-1;s>=0;s--){const r=t.length-s-1,n=new I(t[s],this.l,r),o=f(n.action),c=f(n.subject||this.g);!this.h&&n.fields&&(this.h=!0);for(let a=0;a<c.length;a++){const b=h(e,c[a],v);for(let u=0;u<o.length;u++)h(b,o[u],g).rules.push(n)}}return e}possibleRulesFor(t,e=this.g){if(!l(e))throw new Error('"possibleRulesFor" accepts only subject types (i.e., string or class) as the 2nd parameter');const s=h(this.j,e,v),r=h(s,t,g);if(r.merged)return r.rules;const n=t!==this.p&&s.has(this.p)?s.get(this.p).rules:void 0;let o=y(r.rules,n);return e!==this.g&&(o=y(o,this.possibleRulesFor(t,this.g))),r.rules=o,r.merged=!0,o}rulesFor(t,e,s){const r=this.possibleRulesFor(t,e);if(s&&typeof s!="string")throw new Error("The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details");return this.h?r.filter(n=>n.matchesField(s)):r}actionsFor(t){if(!l(t))throw new Error('"actionsFor" accepts only subject types (i.e., string or class) as a parameter');const e=new Set,s=this.j.get(t);s&&Array.from(s.keys()).forEach(n=>e.add(n));const r=t!==this.g?this.j.get(this.g):void 0;return r&&Array.from(r.keys()).forEach(n=>e.add(n)),Array.from(e)}on(t,e){this.v=this.v||new Map;const s=this.v,r=s.get(t)||null,n=tt(e,r);return s.set(t,n),()=>{const o=s.get(t);!n.next&&!n.prev&&o===n?s.delete(t):n===o&&s.set(t,n.prev),et(n)}}m(t,e){if(!this.v)return;let s=this.v.get(t)||null;for(;s!==null;){const r=s.prev?st(s.prev):null;s.value(e),s=r}}}class lt extends it{can(t,e,s){const r=this.relevantRuleFor(t,e,s);return!!r&&!r.inverted}relevantRuleFor(t,e,s){const r=this.detectSubjectType(e),n=this.rulesFor(t,r,s);for(let o=0,c=n.length;o<c;o++)if(n[o].matchesConditions(e))return n[o];return null}cannot(t,e,s){return!this.can(t,e,s)}}const rt={$eq:q,$ne:T,$lt:S,$lte:E,$gt:_,$gte:R,$in:O,$nin:F,$all:M,$size:x,$regex:A,$options:j,$elemMatch:w,$exists:m},nt={eq:U,ne:Q,lt:K,lte:J,gt:H,gte:G,in:B,nin:Y,all:L,size:z,regex:k,elemMatch:P,exists:N,and:C};$(rt,nt);function ot(i){return typeof i.prototype.possibleRulesFor=="function"}class ct{constructor(t){this.F=t}because(t){return this.F.reason=t,this}}class at{constructor(t){this.rules=[],this._=t,this.can=(e,s,r,n)=>this.O(e,s,r,n,!1),this.cannot=(e,s,r,n)=>this.O(e,s,r,n,!0),this.build=e=>ot(this._)?new this._(this.rules,e):this._(this.rules,e)}O(t,e,s,r,n){const o={action:t};return n&&(o.inverted=n),e&&(o.subject=e,Array.isArray(s)||typeof s=="string"?o.fields=s:typeof s<"u"&&(o.conditions=s),typeof r<"u"&&(o.conditions=r)),this.rules.push(o),new ct(o)}}export{at as A,lt as P};
//# sourceMappingURL=@casl-Dm1p89cb.js.map
